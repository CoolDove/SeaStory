package main

import "core:fmt"
import "core:slice"
import "core:math"
import "core:math/rand"
import "core:math/noise"
import "core:math/linalg"
import rl "vendor:raylib"
import hla "collections/hollow_array"
import pool "collections/pool"

// Rely on game.birds to call `init` and `release`.

BirdHandle :: hla.HollowArrayHandle(Bird)

Bird :: struct {
	using __base : _BirdBase,
	__reserve : [128]u8,// dont go beyond this
}
_BirdBase :: struct {
	type : typeid,
	using vtable : ^_Bird_VTable(Bird),

	hitpoint : int,
	pos : Vec2,

	level : int,

	speed : f64,
	speed_scaler : f64,
	destination : Vec2,
	dest_time : f64,
}

_Bird_VTable :: struct($T:typeid) {
	update : proc(b: ^T, delta: f64),
	pre_draw : proc(b: ^T),
	draw : proc(b: ^T),
	extra_draw : proc(b: ^T),

	init : proc(b: ^T), // after `new`
	prepare : proc(b: ^T, target: rl.Rectangle), // after `prepare`, just generated by the birdgen
	release : proc(b: ^T), // before `free`
}
Bird_VTable_Empty :_Bird_VTable(Bird)= {
	update = proc(b: ^Bird, delta: f64){},
	pre_draw = proc(b: ^Bird) {},
	draw = proc(b: ^Bird) {},
	extra_draw = proc(b: ^Bird) {},

	init = proc(b: ^Bird) {},
	prepare = proc(b: ^Bird, target: rl.Rectangle) {},
	release = proc(b: ^Bird) {},
}

_BirdTargetCandidate :: struct {
	is_building : bool,
	position : Vec2i,
	weight : int,
}

BirdGenerator :: struct {
	wave : BirdWave,
	time : f64,// ms
}

BirdWave :: struct {
	batches : []BirdBatch,
	time : f64,
}

BirdBatch :: struct {
	using config : EnemyBatch,
	born : rl.Rectangle,
	target : rl.Rectangle,
}


bird_init :: proc(type: typeid, bird: ^Bird) {
	bird.type = type
	bird.vtable = auto_cast _bird_vtable(type)
	bird->init()
	assert(type_info_of(type).size<= size_of(Bird), fmt.tprintf("Invalid bird type: {}. Bigger than `Bird`.", bird))
}

_bird_vtable :: proc(t: typeid) -> ^_Bird_VTable(Bird) {
	if t == BlackBird do return auto_cast &BlackBird_VTable
	if t == PufferBird do return auto_cast &PufferBird_VTable
	return nil
}

_bird_move_to_destination :: proc(b: ^Bird, delta: f64, tolerance: f64=0) -> bool/*arrived*/ {
	if b.speed_scaler < 1.0 {
		b.speed_scaler += math.min(1, 1 * delta)
	}
	step := b.speed*b.speed_scaler*auto_cast delta
	if auto_cast linalg.distance(b.destination, b.pos) < step+tolerance {
		return true // arrived
	}
	dir := linalg.normalize(b.destination - b.pos)
	b.pos += dir * auto_cast step
	return false
}

_bird_sort_candidates :: proc(buffer: []_BirdTargetCandidate) {
	slice.sort_by_cmp(buffer, proc(a,b: _BirdTargetCandidate) -> slice.Ordering {
		if a.weight > b.weight do return .Less
		if a.weight < b.weight do return .Greater
		return .Equal
	})
}

_bird_pre_draw :: proc(b: ^Bird) {
	if rl.IsKeyDown(.LEFT_SHIFT) {
		rl.DrawLineEx(b.pos+{0.5, 0.5}, b.destination+{0.5, 0.5}, 0.15, {255,0,0, 80})
	}
}
_bird_draw :: proc(b: ^Bird, tex: rl.Texture) {
	x,y := b.pos.x, b.pos.y
	rl.DrawTexturePro(tex, {0,0,32,32}, {x+0.2,y+0.2, 1,1}, {0,0}, 0, {0,0,64,64})// shadow
	rl.DrawTexturePro(tex, {0,0,32,32}, {x,y, 1,1}, {0,0}, 0, rl.WHITE)
}
_bird_extra_draw :: proc(b: ^Bird) {
	if GAME_DEBUG {
		rl.DrawLineEx(b.pos+{0.5, 0.5}, b.destination+{0.5, 0.5}, 0.05, {255,0,0, 64})
	}
}

bird_get_draw_elem :: proc(b: ^Bird) -> DrawElem {
	vtable := _bird_vtable(b.type)
	return DrawElem{
		b,
		auto_cast b.pos.y+0.05,
		proc(bird: rawptr) {
			bird := cast(^Bird)bird
			bird->pre_draw()
		},
		proc(bird: rawptr) {
			bird := cast(^Bird)bird
			bird->draw()
		},
		proc(bird: rawptr) {
			bird := cast(^Bird)bird
			bird->extra_draw()
		},
		proc(draw: rawptr) {
		}
	}
}

birdgen_is_working :: proc(bg: ^BirdGenerator) -> bool {
	return bg.wave.time > 0
}
birdgen_set :: proc(bg: ^BirdGenerator, config: EnemyWaveConfig) {
	wave : BirdWave
	if len(game.land) == 0 do return

	wave.batches = make([]BirdBatch, len(config.enemies))
	wave.time = config.time
	for enemy_batch_config, i in config.enemies {
		wave.batches[i].config = enemy_batch_config
		batch := &wave.batches[i]
		ite : int
		mother : Vec2i
		for b in hla.ite_alive_value(&game.buildings, &ite) {
			if b.type == Mother {
				mother = b.position
			}
		}
		offset :Vec2i= {cast(int)rand.int31()%4, cast(int)rand.int31()%4}
		w := cast(f32)math.min(4, cast(int)BLOCK_WIDTH-(mother.x-offset.x))
		h := cast(f32)math.min(4, cast(int)BLOCK_WIDTH-(mother.y-offset.y))
		batch.target = {cast(f32)(mother.x-offset.x), cast(f32)(mother.y-offset.y), w, h}

		if bornpos, ok := find_born({auto_cast batch.target.x, auto_cast batch.target.y}, batch.target); ok {
			batch.born = {cast(f32)bornpos.x, cast(f32)bornpos.y, 2,2} 
		} else {
			batch.born = batch.target
		}
	}
	bg.wave = wave
}

birdgen_update :: proc(g: ^Game, bg: ^BirdGenerator, delta: f64) {
	bg.time += delta
	using bg
	if wave.time > 0 {
		wave.time -= delta
		if wave.time <= 0 {// generate birds
			for batch in wave.batches {
				for i in 0..<batch.count {
					pos :Vec2= {rand.float32()*batch.born.width+batch.born.x, rand.float32()*batch.born.height+batch.born.y}
					b := game_add_bird(g, batch.type, pos)
					bird := hla.hla_get_pointer(b)
					bird->prepare(batch.target)
				}
			}
			delete(wave.batches)
			wave.time = 0
		}
	}
}
birdgen_release :: proc(using bg: ^BirdGenerator) {
	if wave.time > 0 {// generate birds
		delete(wave.batches)
		wave.time = 0
	}
}

find_born :: proc(from: [2]int, target: rl.Rectangle) -> (Vec2i, bool) {
	ite:Vec3i
	for p in ite_around(from, 12, &ite) {
		if in_range(p) {
			if _check(p) && _check(p+{0,1}) && _check(p+{1,0}) && _check(p+{1,1}) {
				return p, true
			}
			_check :: proc(p: Vec2i) -> bool {
				return in_range(p) && game.mask[get_index(p)] == 0
			}
		}
	}
	return {}, false
}

birdgen_draw :: proc(bg: ^BirdGenerator) {
	if bg.wave.time != 0 {
		for batch in bg.wave.batches {
			rl.DrawRectangleRoundedLines(batch.born, 0.6, 8, .1, {120,120,60, 128})
			rl.DrawRectangleRoundedLines(batch.target, 0.6, 8, .1, {200,60,60, 128})
			using batch
			from :Vec2= {born.x, born.y} + 0.5 * { born.width, born.height }
			to :Vec2= {target.x, target.y} + 0.5 * { target.width, target.height }
			rl.DrawLineEx(from, to, 0.2, {255,0,0, 64})
			name :cstring
			if batch.type == BlackBird do name = "乌鸦"
			if batch.type == PufferBird do name = "河豚"
			rl.DrawTextEx(FONT_DEFAULT, name, {born.x, born.y}+{0,0}, 1, 0.01, {255,40,40, 128})
		}
	}
}
