package main

import "core:fmt"
import "core:slice"
import "core:math"
import "core:math/rand"
import "core:math/noise"
import "core:math/linalg"
import rl "vendor:raylib"
import hla "collections/hollow_array"
import pool "collections/pool"

// Rely on game.birds to call `init` and `release`.

BirdHandle :: hla.HollowArrayHandle(Bird)

Bird :: struct {
	using __base : _BirdBase,
	__reserve : [128]u8,// dont go beyond this
}
_BirdBase :: struct {
	type : typeid,
	using vtable : ^_Bird_VTable(Bird),

	hitpoint : int,
	pos : Vec2,

	level : int,

	speed : f64,
	speed_scaler : f64,
	destination : Vec2,
	dest_time : f64,
}

_Bird_VTable :: struct($T:typeid) {
	update : proc(b: ^T, delta: f64),
	pre_draw : proc(b: ^T),
	draw : proc(b: ^T),
	extra_draw : proc(b: ^T),

	init : proc(b: ^T), // after `new`
	prepare : proc(b: ^T, target: rl.Rectangle), // after `prepare`, just generated by the birdgen
	release : proc(b: ^T), // before `free`
}
Bird_VTable_Empty :_Bird_VTable(Bird)= {
	update = proc(b: ^Bird, delta: f64){},
	pre_draw = proc(b: ^Bird) {},
	draw = proc(b: ^Bird) {},
	extra_draw = proc(b: ^Bird) {},

	init = proc(b: ^Bird) {},
	prepare = proc(b: ^Bird, target: rl.Rectangle) {},
	release = proc(b: ^Bird) {},
}

_BirdTargetCandidate :: struct {
	is_building : bool,
	position : Vec2i,
	weight : int,
}

BirdGenerator :: struct {
	wave : BirdWave,
	time : f64,// ms
}

BirdWave :: struct {
	using config : EnemyWaveConfig,
	born : rl.Rectangle,
	target : rl.Rectangle,
}


bird_init :: proc(type: typeid, bird: ^Bird) {
	bird.type = type
	bird.vtable = auto_cast _bird_vtable(type)
	bird->init()
	assert(type_info_of(type).size<= size_of(Bird), fmt.tprintf("Invalid bird type: {}. Bigger than `Bird`.", bird))
}

_bird_vtable :: proc(t: typeid) -> ^_Bird_VTable(Bird) {
	if t == BlackBird do return auto_cast &BlackBird_VTable
	if t == PufferBird do return auto_cast &PufferBird_VTable
	return nil
}

_bird_move_to_destination :: proc(b: ^Bird, delta: f64, tolerance: f64=0) -> bool/*arrived*/ {
	if b.speed_scaler < 1.0 {
		b.speed_scaler += math.min(1, 1 * delta)
	}
	step := b.speed*b.speed_scaler*auto_cast delta
	if auto_cast linalg.distance(b.destination, b.pos) < step+tolerance {
		return true // arrived
	}
	dir := linalg.normalize(b.destination - b.pos)
	b.pos += dir * auto_cast step
	return false
}

_bird_sort_candidates :: proc(buffer: []_BirdTargetCandidate) {
	slice.sort_by_cmp(buffer, proc(a,b: _BirdTargetCandidate) -> slice.Ordering {
		if a.weight > b.weight do return .Less
		if a.weight < b.weight do return .Greater
		return .Equal
	})
}

_bird_draw :: proc(b: ^Bird, tex: rl.Texture) {
	x,y := b.pos.x, b.pos.y
	rl.DrawTexturePro(tex, {0,0,32,32}, {x+0.2,y+0.2, 1,1}, {0,0}, 0, {0,0,64,64})// shadow
	rl.DrawTexturePro(tex, {0,0,32,32}, {x,y, 1,1}, {0,0}, 0, rl.WHITE)
}
_bird_extra_draw :: proc(b: ^Bird) {
	if GAME_DEBUG || rl.IsKeyDown(.LEFT_SHIFT) {
		rl.DrawLineV(b.pos+{0.5, 0.5}, b.destination+{0.5, 0.5}, {255,0,0, 64})
	}
}

bird_get_draw_elem :: proc(b: ^Bird) -> DrawElem {
	vtable := _bird_vtable(b.type)
	return DrawElem{
		b,
		auto_cast b.pos.y+0.05,
		proc(bird: rawptr) {
			bird := cast(^Bird)bird
			bird->pre_draw()
		},
		proc(bird: rawptr) {
			bird := cast(^Bird)bird
			bird->draw()
		},
		proc(bird: rawptr) {
			bird := cast(^Bird)bird
			bird->extra_draw()
		},
		proc(draw: rawptr) {
		}
	}
}

birdgen_is_working :: proc(bg: ^BirdGenerator) -> bool {
	return bg.wave.time > 0
}
birdgen_set :: proc(bg: ^BirdGenerator, config: EnemyWaveConfig) {
	wave : BirdWave
	if len(game.land) == 0 do return
	wave.config = config
	ite : int
	mother : Vec2i
	for b in hla.ite_alive_value(&game.buildings, &ite) {
		if b.type == Mother {
			mother = b.position
		}
	}
	offset :Vec2i= {cast(int)rand.int31()%4, cast(int)rand.int31()%4}
	w := cast(f32)math.min(4, cast(int)BLOCK_WIDTH-(mother.x-offset.x))
	h := cast(f32)math.min(4, cast(int)BLOCK_WIDTH-(mother.y-offset.y))
	wave.target = {cast(f32)(mother.x-offset.x), cast(f32)(mother.y-offset.y), w, h}

	bx := cast(f32)(rand.int31()%cast(i32)(BLOCK_WIDTH-4))
	by := cast(f32)(rand.int31()%cast(i32)(BLOCK_WIDTH-4))
	wave.born = {bx,by, 4,4}

	bg.wave = wave
}

birdgen_update :: proc(g: ^Game, bg: ^BirdGenerator, delta: f64) {
	bg.time += delta
	using bg
	if wave.time > 0 {
		wave.time -= delta
		if wave.time <= 0 {// generate birds
			for e in wave.enemies {
				for i in 0..<e.count {
					pos :Vec2= {rand.float32()*wave.born.width+wave.born.x, rand.float32()*wave.born.height+wave.born.y}
					b := game_add_bird(g, e.type, pos)
					bird := hla.hla_get_pointer(b)
					bird->prepare(wave.target)
				}
			}
			wave.time = 0
		}
	}
}

find_empty_cell :: proc(g: ^Game, from: [2]int, buffer: ^[BLOCK_WIDTH*BLOCK_WIDTH]u32, dir:u32=0xff) -> ([2]int, bool) {
	DIR_NONE :: 0
	DIR_ROOT :: 0xff
	DIR_UP :: 1
	DIR_DOWN :: 2
	DIR_LEFT :: 3
	DIR_RIGHT :: 4
	if !in_range(from.x, from.y) do return {}, false
	idx := get_index(from.x, from.y)
	buffer[idx] = dir
	if g.mask[idx] == 0 do return from, true
	if tup := from+{0,1}; in_range(tup.x, tup.y) && buffer[get_index(tup.x, tup.y)] != DIR_NONE {
		if up, up_ok := find_empty_cell(g, from+{0,1}, buffer); up_ok do return up, true
	}
	if tdown := from+{0,1}; in_range(tdown.x, tdown.y) && buffer[get_index(tdown.x, tdown.y)] != DIR_NONE {
		if down, down_ok := find_empty_cell(g, from+{0,1}, buffer); down_ok do return down, true
	}
	if tleft := from+{0,1}; in_range(tleft.x, tleft.y) && buffer[get_index(tleft.x, tleft.y)] != DIR_NONE {
		if left, left_ok := find_empty_cell(g, from+{0,1}, buffer); left_ok do return left, true
	}
	if tright := from+{0,1}; in_range(tright.x, tright.y) && buffer[get_index(tright.x, tright.y)] != DIR_NONE {
		if right, right_ok := find_empty_cell(g, from+{0,1}, buffer); right_ok do return right, true
	}
	return {}, false
}

birdgen_draw :: proc(bg: ^BirdGenerator) {
	if bg.wave.time != 0 {
		rl.DrawRectangleRoundedLines(bg.wave.born, 0.6, 8, .1, {120,120,60, 128})
		rl.DrawRectangleRoundedLines(bg.wave.target, 0.6, 8, .1, {200,60,60, 128})
	}
}
